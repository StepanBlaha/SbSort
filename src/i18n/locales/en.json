{  
    "main":{
        "title": "Sorting Visualizer",
        "subtitle": "Learn sorting algorithms through step-by-step visual guides",
        "sorts_title": "Sorting Algorithms",
        "sorts":{
            "bubble": "Bubble Sort",
            "merge": "Merge Sort",
            "selection": "Selection Sort",
            "quick": "Quick Sort",
            "insertion": "Insertion Sort",
            "heap": "Heap Sort",
            "counting": "Counting Sort"
        }
    },
    "hero":{
        
        "bubble": {
            "title": "Bubble Sort",
            "subtitle": "Step-by-step visual explanation of Bubble Sort."
        },
        "merge": {
            "title": "Merge Sort",
            "subtitle": "Step-by-step visual explanation of Merge Sort."
        },
        "Heap": {
            "title": "Heap Sort",
            "subtitle": "Step-by-step visual explanation of Heap Sort."
        },
        "quick": {
            "title": "Quick Sort",
            "subtitle": "Step-by-step visual explanation of Quick Sort."
        },
        "selection": {
            "title": "Selection Sort",
            "subtitle": "Step-by-step visual explanation of Selection Sort."
        },
        "insertion": {
            "title": "Insertion Sort",
            "subtitle": "Step-by-step visual explanation of Insertion Sort."
        },
        "counting": {
            "title": "Counting Sort",
            "subtitle": "Step-by-step visual explanation of Counting Sort."
        }
    },
    "console": {
        "input": "Input array",
        "reset": "Reset",
        "speed": "Speed",
        "visualization": "Visualization",
        "how": "How it works",
        "time": "Time complexity",
        "when": "When to use",
        "how_list":{
            "bubble": {
                "1": "Compare each pair of adjacent elements",
                "2": "Swap them if they are in the wrong order",
                "3": "After each pass, the largest element moves to the end",
                "4": "Repeat the process for the remaining unsorted part",
                "5": "Stop when no swaps are needed (array is sorted)"
            },
            "counting": {
                "1": "Find the range of input values",
                "2": "Count the occurrences of each value",
                "3": "Compute the cumulative counts to determine positions",
                "4": "Place each element in its sorted position in the output array"            
            },
            "heap": {
                "1": "Build a max heap from the array",
                "2": "Swap the root (max) with the last element",
                "3": "Reduce heap size and heapify to restore max heap",
                "4": "Repeat until all elements are sorted"            
            },
            "insertion": {
                "1": "Take elements one by one from the unsorted part",
                "2": "Insert each into its correct position in the sorted part",
                "3": "Shift larger elements one step to the right when needed"            
            },
            "merge": {
                "1": "Divide the array into two halves",
                "2": "Recursively sort each half",
                "3": "Merge the two sorted halves into one sorted array"
            },
            "quick": {
                "1": "Pick a pivot element",
                "2": "Partition array so smaller elements go left, larger go right",
                "3": "Recursively apply the process to left and right partitions"
            },
            "selection": {
                "1": "Find the minimum element in the unsorted part",
                "2": "Swap it with the first unsorted element",
                "3": "Move the boundary of sorted/unsorted part one step forward",
                "4": "Repeat until all elements are sorted"            
            }
        },
        "time_list":{
            "bubble": {
                "1": "Compare each pair of adjacent elements",
                "2": "Swap them if they are in the wrong order",
                "3": "After each pass, the largest element moves to the end",
                "4": "Repeat the process for the remaining unsorted part",
                "5": "Stop when no swaps are needed (array is sorted)"
            },
            "counting": {
                "1": "Compare each pair of adjacent elements",
                "2": "Swap them if they are in the wrong order",
                "3": "After each pass, the largest element moves to the end",
                "4": "Repeat the process for the remaining unsorted part",
                "5": "Stop when no swaps are needed (array is sorted)"
            },
            "heap": {
                "1": "Compare each pair of adjacent elements",
                "2": "Swap them if they are in the wrong order",
                "3": "After each pass, the largest element moves to the end",
                "4": "Repeat the process for the remaining unsorted part",
                "5": "Stop when no swaps are needed (array is sorted)"
            },
            "insertion": {
                "1": "Compare each pair of adjacent elements",
                "2": "Swap them if they are in the wrong order",
                "3": "After each pass, the largest element moves to the end",
                "4": "Repeat the process for the remaining unsorted part",
                "5": "Stop when no swaps are needed (array is sorted)"
            },
            "merge": {
                "1": "Compare each pair of adjacent elements",
                "2": "Swap them if they are in the wrong order",
                "3": "After each pass, the largest element moves to the end",
                "4": "Repeat the process for the remaining unsorted part",
                "5": "Stop when no swaps are needed (array is sorted)"
            },
            "quick": {
                "1": "Compare each pair of adjacent elements",
                "2": "Swap them if they are in the wrong order",
                "3": "After each pass, the largest element moves to the end",
                "4": "Repeat the process for the remaining unsorted part",
                "5": "Stop when no swaps are needed (array is sorted)"
            },
            "selection": {
                "1": "Compare each pair of adjacent elements",
                "2": "Swap them if they are in the wrong order",
                "3": "After each pass, the largest element moves to the end",
                "4": "Repeat the process for the remaining unsorted part",
                "5": "Stop when no swaps are needed (array is sorted)"
            }
        },
        "when_list":{
            "bubble": {
                "1": "When teaching or learning sorting basics (easy to understand)",
                "2": "For very small arrays where simplicity is more important than efficiency",
                "3": "When the array is almost sorted and only a few swaps are needed",
                "4": "Useful for demonstrating algorithm concepts (swapping, comparisons, passes)"
            },
            "counting": {
                "1": "When sorting integers or discrete values",
                "2": "When the range of numbers (k) is not much larger than the number of elements (n)",
                "3": "For stable and linear-time sorting of small-range data"
            },
            "heap": {
                "1": "When O(n log n) worst-case is required",
                "2": "When in-place sorting is needed",
                "3": "Good for systems with limited memory"
            },
            "insertion": {
                "1": "For small datasets",
                "2": "When data is almost sorted",
                "3": "As a building block for more advanced algorithms"
            },
            "merge": {
                "1": "For large datasets",
                "2": "When stability (keeping order of equal elements) matters",
                "3": "When guaranteed O(n log n) is required"
            },
            "quick": {
                "1": "For large datasets",
                "2": "When average performance matters",
                "3": "When in-place sorting is preferred"
            },
            "selection": {
                "1": "When memory writes are costly (few swaps)",
                "2": "For very small datasets",
                "3": "For educational purposes"
            }
        }
    },
    "alert":{
        "success": {
            "title": "Success",
            "text": "Text copied successfully."
        },
        "error": {
            "title": "Error",
            "text": "Sorry something went wrong, please try again."
        }
    },
    "footer":{
        "stack":{
            "framework": "Built with",
            "styles": "Styled with",
            "deploy": "Deployed on"
        },
        "right": "All Rights Reserved.",
        "message": "Built and Designed with"
    },
    "navbar":{
        "sections":{
            "home": "Home",
            "about": "About",
            "list": "Sort Types",
            "projects": "PROJECTS",
            "contacts": "CONTACTS"
        },
        "language": "Change Language"
    }
}