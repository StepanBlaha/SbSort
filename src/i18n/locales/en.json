{  
    "main":{
        "title": "SBSORT - Where Algorithms Come to Life",
        "subtitle": "Dynamic visualizations that transform the way we learn sorting algorithms. Explore 12+ algorithms through interactive animations, compare their performance on different datasets, and gain practical knowledge you can immediately apply in your projects.",
        "sorts_title": "Sorting Algorithms",
        "visualize_button": "Try the Visualizer",
        "learn_button": "Learn More",
        "sorts":{
            "bubble": "Bubble Sort",
            "merge": "Merge Sort",
            "selection": "Selection Sort",
            "quick": "Quick Sort",
            "insertion": "Insertion Sort",
            "heap": "Heap Sort",
            "counting": "Counting Sort"
        },
        "sort_desc":{
            "bubble": "Watch pairs of bars swap until everything floats into place.",
            "insertion": "Slide each element into its place as if arranging puzzle pieces.",
            "selection": "Pull out the smallest, lock it in place, and repeat the ritual.",
            "merge": "Divide the array, conquer smaller parts, then merge them flawlessly.",
            "quick": "Choose a pivot, partition the array, and sort each side fast.",
            "heap":"Use a binary heap to repeatedly select the next element in order.",
            "counting": "Count occurrences of each value and place them by cumulative counts."
        }
    },
    "buttons":{
        "play": "Play"
    },
    "about":{
        "badge": "About SBSORT -- Sorting Visualizer",
        "title": "We make sorting algorithms ",
        "title_highlight": "click.",
        "subtitle": "SBSORT turns textbook algorithms into visual, step‑by‑step animations. Explore different strategies, compare their trade‑offs, and build intuition by watching them sort the very same array side‑by‑side.",
        "concepts":{
            "title":"Concepts you can see",
            "subtitle": "Animations reveal comparisons, swaps, and partitions so the logic behind each algorithm becomes obvious."
        },
        "time":{
            "title": "Time & space intuition",
            "subtitle": "Built‑in notes and complexity tables connect what you see to Big‑O analysis and real‑world constraints."
        },
        "controls":{
            "title": "Interactive controls",
            "subtitle": "Change the input array, step through frames, or adjust speed to investigate best, average, and worst cases."
        },
        "how":{
            "title": "How SBSORT teaches",
            "1":{
                "title": "Pick an algorithm",
                "subtitle": "Select Bubble, Insertion, Selection, Merge, Quick, Heap and more — each with a concise explanation and typical use‑cases."
            },
            "2":{
                "title": "Set your experiment",
                "subtitle": "Enter a custom array or randomize one. Choose visualization speed and whether to highlight swaps, pivots, or partitions."
            },
            "3":{
                "title": "Watch, pause, inspect",
                "subtitle": "Play the animation, pause at any frame, and read the side notes to understand the exact operation at each step."
            },
            "4":{
                "title": "Compare & conclude",
                "subtitle": "See how input order and size affect runtime. Learn when a simple algorithm is perfect — and when divide‑and‑conquer wins."
            }
        },
        "why":{
            "title":"Why learners choose SBSORT",
            "algorithms":{
                "title":"12+",
                "subtitle": "algorithms visualized"
            },
            "notation":{
                "title":"Step-by-step",
                "subtitle": "explanations with Big-O"
            },
            "accessible":{
                "title":"Accessible",
                "subtitle": "keyboard & screen-reader friendly"
            },
            "languages":{
                "title":"Multilingual",
                "subtitle": "EN / CZ ready"
            }
        },
        "who":{
            "title": "Who’s behind the project",
            "name":"Stepan Blaha",
            "role": "Creator & Engineer — builds the visualizations and content."
        },
        "faq":{
            "title": "Frequently asked questions",
            "1":{
                "title": "Can I use SBSORT in my course?",
                "subtitle": "Yes. It’s designed for classrooms and self‑study. You can embed lessons or project it live during lectures."
            },
            "2":{
                "title": "Does it work on mobile?",
                "subtitle": "Absolutely. The UI scales down to phones and tablets with touch‑friendly controls."
            },
            "3":{
                "title": "What about dark mode and languages?",
                "subtitle": "Dark/light themes are built‑in. English and Czech are supported, and more languages can be added."
            },
            "4":{
                "title": "Is SBSORT open source?",
                "subtitle": "The visualizer core can be shared for educational use. Contact us for licensing or contributions."
            }
        }

    },
    "hero":{
        
        "bubble": {
            "title": "Bubble Sort",
            "subtitle": "Step-by-step visual explanation of Bubble Sort."
        },
        "merge": {
            "title": "Merge Sort",
            "subtitle": "Step-by-step visual explanation of Merge Sort."
        },
        "Heap": {
            "title": "Heap Sort",
            "subtitle": "Step-by-step visual explanation of Heap Sort."
        },
        "quick": {
            "title": "Quick Sort",
            "subtitle": "Step-by-step visual explanation of Quick Sort."
        },
        "selection": {
            "title": "Selection Sort",
            "subtitle": "Step-by-step visual explanation of Selection Sort."
        },
        "insertion": {
            "title": "Insertion Sort",
            "subtitle": "Step-by-step visual explanation of Insertion Sort."
        },
        "counting": {
            "title": "Counting Sort",
            "subtitle": "Step-by-step visual explanation of Counting Sort."
        }
    },
    "sort_list": {
        "badge":"Sort Types SBSORT -- Sorting Visualizer",
        "title": "List of all sorting ",
        "title_highlighted": "algorithms.",
        "subtitle":"Curated list of all of our sorting algorithms ready for easy navigation. Simply pick the algorithm you want to learn, click the button to redirect you to the visualzer page and start learning.",
        "algorithms": {
            "bubble": {
                "title": "Bubble Sort",
                "description": "Repeatedly swaps adjacent elements until sorted"
            },
            "merge": {
                "title": "Merge Sort", 
                "description": "Divides array, sorts halves, and merges them"
            },
            "selection": {
                "title": "Selection Sort",
                "description": "Repeatedly selects the smallest element and places it"
            },
            "quick": {
                "title": "Quick Sort",
                "description": "Partitions array around a pivot and sorts recursively"
            },
            "insertion": {
                "title": "Insertion Sort",
                "description": "Builds sorted list by inserting elements one by one"
            },
            "heap": {
                "title": "Heap Sort",
                "description": "Uses a heap structure to repeatedly extract max/min"
            },
            "counting": {
                "title": "Counting Sort",
                "description": "Counts element frequencies to place them in order"
            }
        }
    },
    "console": {
        "input": "Input array",
        "reset": "Reset",
        "speed": "Speed",
        "visualization": "Visualization",
        "how": "How it works",
        "time": "Time complexity",
        "when": "When to use",
        "complexity_labels": {
            "best_case": "Best Case",
            "average_case": "Average Case", 
            "worst_case": "Worst Case",
            "space_complexity": "Space Complexity"
        },
        "how_list":{
            "bubble": {
                "1": "Compare each pair of adjacent elements",
                "2": "Swap them if they are in the wrong order",
                "3": "After each pass, the largest element moves to the end",
                "4": "Repeat the process for the remaining unsorted part",
                "5": "Stop when no swaps are needed (array is sorted)"
            },
            "counting": {
                "1": "Find the range of input values",
                "2": "Count the occurrences of each value",
                "3": "Compute the cumulative counts to determine positions",
                "4": "Place each element in its sorted position in the output array"            
            },
            "heap": {
                "1": "Build a max heap from the array",
                "2": "Swap the root (max) with the last element",
                "3": "Reduce heap size and heapify to restore max heap",
                "4": "Repeat until all elements are sorted"            
            },
            "insertion": {
                "1": "Take elements one by one from the unsorted part",
                "2": "Insert each into its correct position in the sorted part",
                "3": "Shift larger elements one step to the right when needed"            
            },
            "merge": {
                "1": "Divide the array into two halves",
                "2": "Recursively sort each half",
                "3": "Merge the two sorted halves into one sorted array"
            },
            "quick": {
                "1": "Pick a pivot element",
                "2": "Partition array so smaller elements go left, larger go right",
                "3": "Recursively apply the process to left and right partitions"
            },
            "selection": {
                "1": "Find the minimum element in the unsorted part",
                "2": "Swap it with the first unsorted element",
                "3": "Move the boundary of sorted/unsorted part one step forward",
                "4": "Repeat until all elements are sorted"            
            }
        },
        "time_list": {
            "bubble": {
                "best_case": {
                    "complexity": "O(n)",
                    "description": "when the array is already sorted (with optimized version that stops if no swaps are made)"
                },
                "average_case": {
                    "complexity": "O(n²)",
                    "description": "typical performance when elements are in random order"
                },
                "worst_case": {
                    "complexity": "O(n²)",
                    "description": "when the array is sorted in reverse order"
                },
                "space_complexity": {
                    "complexity": "O(1)",
                    "description": "since it sorts in place"
                }
            },
            "merge": {
                "best_case": {
                    "complexity": "O(n log n)",
                    "description": "consistent performance regardless of input order"
                },
                "average_case": {
                    "complexity": "O(n log n)",
                    "description": "reliable divide-and-conquer approach"
                },
                "worst_case": {
                    "complexity": "O(n log n)",
                    "description": "guaranteed performance even with worst input"
                },
                "space_complexity": {
                    "complexity": "O(n)",
                    "description": "requires additional memory for temporary arrays during merging"
                }
            },
            "selection": {
                "best_case": {
                    "complexity": "O(n²)",
                    "description": "always needs to find minimum in remaining array"
                },
                "average_case": {
                    "complexity": "O(n²)",
                    "description": "constant number of comparisons regardless of input"
                },
                "worst_case": {
                    "complexity": "O(n²)",
                    "description": "no difference based on input data arrangement"
                },
                "space_complexity": {
                    "complexity": "O(1)",
                    "description": "sorts in place with only a few variables"
                }
            },
            "quick": {
                "best_case": {
                    "complexity": "O(n log n)",
                    "description": "when pivot divides array into equal halves"
                },
                "average_case": {
                    "complexity": "O(n log n)",
                    "description": "with random or median-of-three pivot selection"
                },
                "worst_case": {
                    "complexity": "O(n²)",
                    "description": "when pivot is always the smallest or largest element"
                },
                "space_complexity": {
                    "complexity": "O(log n)",
                    "description": "for recursive function calls on the stack"
                }
            },
            "insertion": {
                "best_case": {
                    "complexity": "O(n)",
                    "description": "when the array is already sorted"
                },
                "average_case": {
                    "complexity": "O(n²)",
                    "description": "when elements are in random order"
                },
                "worst_case": {
                    "complexity": "O(n²)",
                    "description": "when the array is sorted in reverse order"
                },
                "space_complexity": {
                    "complexity": "O(1)",
                    "description": "sorts in place with only a constant amount of extra space"
                }
            },
            "heap": {
                "best_case": {
                    "complexity": "O(n log n)",
                    "description": "building heap takes O(n), extracting all elements takes O(n log n)"
                },
                "average_case": {
                    "complexity": "O(n log n)",
                    "description": "consistent performance across different inputs"
                },
                "worst_case": {
                    "complexity": "O(n log n)",
                    "description": "guaranteed performance regardless of input arrangement"
                },
                "space_complexity": {
                    "complexity": "O(1)",
                    "description": "sorts in place using the input array as heap"
                }
            },
            "counting": {
                "best_case": {
                    "complexity": "O(n + k)",
                    "description": "where k is the range of input values"
                },
                "average_case": {
                    "complexity": "O(n + k)",
                    "description": "linear time complexity independent of input order"
                },
                "worst_case": {
                    "complexity": "O(n + k)",
                    "description": "still linear even with worst case input"
                },
                "space_complexity": {
                    "complexity": "O(k)",
                    "description": "requires additional array to count occurrences"
                }
            }
        },
        "when_list":{
            "bubble": {
                "1": "When teaching or learning sorting basics (easy to understand)",
                "2": "For very small arrays where simplicity is more important than efficiency",
                "3": "When the array is almost sorted and only a few swaps are needed",
                "4": "Useful for demonstrating algorithm concepts (swapping, comparisons, passes)"
            },
            "counting": {
                "1": "When sorting integers or discrete values",
                "2": "When the range of numbers (k) is not much larger than the number of elements (n)",
                "3": "For stable and linear-time sorting of small-range data"
            },
            "heap": {
                "1": "When O(n log n) worst-case is required",
                "2": "When in-place sorting is needed",
                "3": "Good for systems with limited memory"
            },
            "insertion": {
                "1": "For small datasets",
                "2": "When data is almost sorted",
                "3": "As a building block for more advanced algorithms"
            },
            "merge": {
                "1": "For large datasets",
                "2": "When stability (keeping order of equal elements) matters",
                "3": "When guaranteed O(n log n) is required"
            },
            "quick": {
                "1": "For large datasets",
                "2": "When average performance matters",
                "3": "When in-place sorting is preferred"
            },
            "selection": {
                "1": "When memory writes are costly (few swaps)",
                "2": "For very small datasets",
                "3": "For educational purposes"
            }
        }
    },
    "alert":{
        "success": {
            "title": "Success",
            "text": "Text copied successfully."
        },
        "error": {
            "title": "Error",
            "text": "Sorry something went wrong, please try again."
        }
    },
    "footer":{
        "stack":{
            "framework": "Built with",
            "styles": "Styled with",
            "deploy": "Deployed on"
        },
        "right": "All Rights Reserved.",
        "message": "Built and Designed with"
    },
    "navbar":{
        "sections":{
            "home": "Home",
            "about": "About",
            "list": "Sort Types",
            "projects": "PROJECTS",
            "contacts": "CONTACTS"
        },
        "language": "Change Language"
    }
}