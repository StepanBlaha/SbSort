{  
    "main":{
        "title": "Sorting Visualizer",
        "subtitle": "Learn sorting algorithms through step-by-step visual guides",
        "sorts_title": "Sorting Algorithms",
        "sorts":{
            "bubble": "Bubble Sort",
            "merge": "Merge Sort",
            "selection": "Selection Sort",
            "quick": "Quick Sort",
            "insertion": "Insertion Sort",
            "heap": "Heap Sort",
            "counting": "Counting Sort"
        },
        "sort_desc":{
            "bubble": "Watch pairs of bars swap until everything floats into place.",
            "insertion": "Slide each element into its place as if arranging puzzle pieces.",
            "selection": "Pull out the smallest, lock it in place, and repeat the ritual.",
            "merge": "Divide the array, conquer smaller parts, then merge them flawlessly.",
            "quick": "Choose a pivot, partition the array, and sort each side fast.",
            "heap":"Use a binary heap to repeatedly select the next element in order.",
            "counting": "Count occurrences of each value and place them by cumulative counts."
        }
    },
    "buttons":{
        "play": "Play"
    },
    "hero":{
        
        "bubble": {
            "title": "Bubble Sort",
            "subtitle": "Step-by-step visual explanation of Bubble Sort."
        },
        "merge": {
            "title": "Merge Sort",
            "subtitle": "Step-by-step visual explanation of Merge Sort."
        },
        "Heap": {
            "title": "Heap Sort",
            "subtitle": "Step-by-step visual explanation of Heap Sort."
        },
        "quick": {
            "title": "Quick Sort",
            "subtitle": "Step-by-step visual explanation of Quick Sort."
        },
        "selection": {
            "title": "Selection Sort",
            "subtitle": "Step-by-step visual explanation of Selection Sort."
        },
        "insertion": {
            "title": "Insertion Sort",
            "subtitle": "Step-by-step visual explanation of Insertion Sort."
        },
        "counting": {
            "title": "Counting Sort",
            "subtitle": "Step-by-step visual explanation of Counting Sort."
        }
    },
    "sort_list": {
        "title": "Sorting Algorithms",
        "algorithms": {
            "bubble": {
                "title": "Bubble Sort",
                "description": "Repeatedly swaps adjacent elements until sorted"
            },
            "merge": {
                "title": "Merge Sort", 
                "description": "Divides array, sorts halves, and merges them"
            },
            "selection": {
                "title": "Selection Sort",
                "description": "Repeatedly selects the smallest element and places it"
            },
            "quick": {
                "title": "Quick Sort",
                "description": "Partitions array around a pivot and sorts recursively"
            },
            "insertion": {
                "title": "Insertion Sort",
                "description": "Builds sorted list by inserting elements one by one"
            },
            "heap": {
                "title": "Heap Sort",
                "description": "Uses a heap structure to repeatedly extract max/min"
            },
            "counting": {
                "title": "Counting Sort",
                "description": "Counts element frequencies to place them in order"
            }
        }
    },
    "console": {
        "input": "Input array",
        "reset": "Reset",
        "speed": "Speed",
        "visualization": "Visualization",
        "how": "How it works",
        "time": "Time complexity",
        "when": "When to use",
        "complexity_labels": {
            "best_case": "Best Case",
            "average_case": "Average Case", 
            "worst_case": "Worst Case",
            "space_complexity": "Space Complexity"
        },
        "how_list":{
            "bubble": {
                "1": "Compare each pair of adjacent elements",
                "2": "Swap them if they are in the wrong order",
                "3": "After each pass, the largest element moves to the end",
                "4": "Repeat the process for the remaining unsorted part",
                "5": "Stop when no swaps are needed (array is sorted)"
            },
            "counting": {
                "1": "Find the range of input values",
                "2": "Count the occurrences of each value",
                "3": "Compute the cumulative counts to determine positions",
                "4": "Place each element in its sorted position in the output array"            
            },
            "heap": {
                "1": "Build a max heap from the array",
                "2": "Swap the root (max) with the last element",
                "3": "Reduce heap size and heapify to restore max heap",
                "4": "Repeat until all elements are sorted"            
            },
            "insertion": {
                "1": "Take elements one by one from the unsorted part",
                "2": "Insert each into its correct position in the sorted part",
                "3": "Shift larger elements one step to the right when needed"            
            },
            "merge": {
                "1": "Divide the array into two halves",
                "2": "Recursively sort each half",
                "3": "Merge the two sorted halves into one sorted array"
            },
            "quick": {
                "1": "Pick a pivot element",
                "2": "Partition array so smaller elements go left, larger go right",
                "3": "Recursively apply the process to left and right partitions"
            },
            "selection": {
                "1": "Find the minimum element in the unsorted part",
                "2": "Swap it with the first unsorted element",
                "3": "Move the boundary of sorted/unsorted part one step forward",
                "4": "Repeat until all elements are sorted"            
            }
        },
        "time_list": {
            "bubble": {
                "best_case": {
                    "complexity": "O(n)",
                    "description": "when the array is already sorted (with optimized version that stops if no swaps are made)"
                },
                "average_case": {
                    "complexity": "O(n²)",
                    "description": "typical performance when elements are in random order"
                },
                "worst_case": {
                    "complexity": "O(n²)",
                    "description": "when the array is sorted in reverse order"
                },
                "space_complexity": {
                    "complexity": "O(1)",
                    "description": "since it sorts in place"
                }
            },
            "merge": {
                "best_case": {
                    "complexity": "O(n log n)",
                    "description": "consistent performance regardless of input order"
                },
                "average_case": {
                    "complexity": "O(n log n)",
                    "description": "reliable divide-and-conquer approach"
                },
                "worst_case": {
                    "complexity": "O(n log n)",
                    "description": "guaranteed performance even with worst input"
                },
                "space_complexity": {
                    "complexity": "O(n)",
                    "description": "requires additional memory for temporary arrays during merging"
                }
            },
            "selection": {
                "best_case": {
                    "complexity": "O(n²)",
                    "description": "always needs to find minimum in remaining array"
                },
                "average_case": {
                    "complexity": "O(n²)",
                    "description": "constant number of comparisons regardless of input"
                },
                "worst_case": {
                    "complexity": "O(n²)",
                    "description": "no difference based on input data arrangement"
                },
                "space_complexity": {
                    "complexity": "O(1)",
                    "description": "sorts in place with only a few variables"
                }
            },
            "quick": {
                "best_case": {
                    "complexity": "O(n log n)",
                    "description": "when pivot divides array into equal halves"
                },
                "average_case": {
                    "complexity": "O(n log n)",
                    "description": "with random or median-of-three pivot selection"
                },
                "worst_case": {
                    "complexity": "O(n²)",
                    "description": "when pivot is always the smallest or largest element"
                },
                "space_complexity": {
                    "complexity": "O(log n)",
                    "description": "for recursive function calls on the stack"
                }
            },
            "insertion": {
                "best_case": {
                    "complexity": "O(n)",
                    "description": "when the array is already sorted"
                },
                "average_case": {
                    "complexity": "O(n²)",
                    "description": "when elements are in random order"
                },
                "worst_case": {
                    "complexity": "O(n²)",
                    "description": "when the array is sorted in reverse order"
                },
                "space_complexity": {
                    "complexity": "O(1)",
                    "description": "sorts in place with only a constant amount of extra space"
                }
            },
            "heap": {
                "best_case": {
                    "complexity": "O(n log n)",
                    "description": "building heap takes O(n), extracting all elements takes O(n log n)"
                },
                "average_case": {
                    "complexity": "O(n log n)",
                    "description": "consistent performance across different inputs"
                },
                "worst_case": {
                    "complexity": "O(n log n)",
                    "description": "guaranteed performance regardless of input arrangement"
                },
                "space_complexity": {
                    "complexity": "O(1)",
                    "description": "sorts in place using the input array as heap"
                }
            },
            "counting": {
                "best_case": {
                    "complexity": "O(n + k)",
                    "description": "where k is the range of input values"
                },
                "average_case": {
                    "complexity": "O(n + k)",
                    "description": "linear time complexity independent of input order"
                },
                "worst_case": {
                    "complexity": "O(n + k)",
                    "description": "still linear even with worst case input"
                },
                "space_complexity": {
                    "complexity": "O(k)",
                    "description": "requires additional array to count occurrences"
                }
            }
        },
        "when_list":{
            "bubble": {
                "1": "When teaching or learning sorting basics (easy to understand)",
                "2": "For very small arrays where simplicity is more important than efficiency",
                "3": "When the array is almost sorted and only a few swaps are needed",
                "4": "Useful for demonstrating algorithm concepts (swapping, comparisons, passes)"
            },
            "counting": {
                "1": "When sorting integers or discrete values",
                "2": "When the range of numbers (k) is not much larger than the number of elements (n)",
                "3": "For stable and linear-time sorting of small-range data"
            },
            "heap": {
                "1": "When O(n log n) worst-case is required",
                "2": "When in-place sorting is needed",
                "3": "Good for systems with limited memory"
            },
            "insertion": {
                "1": "For small datasets",
                "2": "When data is almost sorted",
                "3": "As a building block for more advanced algorithms"
            },
            "merge": {
                "1": "For large datasets",
                "2": "When stability (keeping order of equal elements) matters",
                "3": "When guaranteed O(n log n) is required"
            },
            "quick": {
                "1": "For large datasets",
                "2": "When average performance matters",
                "3": "When in-place sorting is preferred"
            },
            "selection": {
                "1": "When memory writes are costly (few swaps)",
                "2": "For very small datasets",
                "3": "For educational purposes"
            }
        }
    },
    "alert":{
        "success": {
            "title": "Success",
            "text": "Text copied successfully."
        },
        "error": {
            "title": "Error",
            "text": "Sorry something went wrong, please try again."
        }
    },
    "footer":{
        "stack":{
            "framework": "Built with",
            "styles": "Styled with",
            "deploy": "Deployed on"
        },
        "right": "All Rights Reserved.",
        "message": "Built and Designed with"
    },
    "navbar":{
        "sections":{
            "home": "Home",
            "about": "About",
            "list": "Sort Types",
            "projects": "PROJECTS",
            "contacts": "CONTACTS"
        },
        "language": "Change Language"
    }
}